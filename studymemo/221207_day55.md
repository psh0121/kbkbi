# [D+55] 자바프로그래밍1

## 변수와 자료형

### • 변수

변수는 메모리에 공간을 할당하고 이를 접근하기 위한 이름이다.<br>
ex) 메모리를 만들고 그 메모리에 a라는 이름을 지어주었을 때 a를 변수라고 한다.<br><br>

### • 자료형

자료형은 변수를 만들기 위한 형식으로 크기와 규칙이 내포되어 있다.<br>

```
int a;			// size: 4byte, rule: 정수
float a;		// size: 4byte, rule: 실수
double a;		// size: 8byte, rule: 실수
boolean a;		// size: 1byte, rule: 진리값

Student a;		// size: 4byte, rule: 참조값
Animal a;		// size: 4byte, rule: 참조값

// 참조값이 들어있는 Student a와 Animal의 a는 실체는 따로 있다.

// Studnet형과 Animal의 경우 각각의 크기가 다르다고해서 
//참조값의 크기가 변하지 않기 때문에 모든 참조값의 크기는 4byte로 동일하다.
```
<br><br>

### • 자료형의 종류

\- <b>Primitive Data type</b> : 자바의 기본 자료형<br>
\- <b>Non-Primitive Data type</b> : 확장된 자료형 (user-defined type)<br>
<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb6XRlF%2FbtrS6i7zIKX%2Fz0RgXjYmmHo2dMdc7X2yI0%2Fimg.png" width="80%"/><br><br>

### • 자료형의 종류 : 정수

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbrwGRc%2FbtrS5j0rIfb%2F9RehVG8fQsrPBra8wH9C90%2Fimg.png" width="45%"/>

\- 모든 데이터타입의 기본형은 정수형이다. (판단하기 어려운 상황에서는 정수로 처리해버리기도 한다.)<br><br>

\- 부호비트(1) + 데이터 비트(31)<br>
\- <b>부호비트 (sign-bit)</b> : 0(양의 정수) / 1(음의 정수)<br>
\- 음수는 부호비트는 1로하고 데이터 비트는 2의 보수로 처리한다.<br>
\- 자바에서는 부호비트를 반드시 포함하는데 이유는 애매모호한 문제가 발생될 수도 있기 때문에 엄격하게 부호비트를 가지도록 설정해 주었다.<br><br>

ex) -21억 + 21억 = 0<br>
0은 모든 비트가 0으로 셋팅되어야 한다.<br>
그런데 만약 -21억이 sign-bit이고 21억이 unsigned라면 두 값을 더했을 경우 사인비트로 인해 모든 값이 0이 안나오는 경우가 발생될 수도 있다.<br><br>

#### <b>정수형에서 선호하는 데이터 타입은?</b>

\- 일반적으로 Data-bus는 1채널이 32bit 이기 때문에 어느크기의 데이터타입이던 I/O속도는 동일하다. (short가 내부적으로 integer화 하는 과정을 거쳐야 한다)<br>
\- 기본적으로 정수는 int로 처리하기 때문에 상호 호환성 측면에서도 int가 이득이다.<br>
\- short형을 만든 이유는 성능이나 기능 측면에서 만들었다기 보다는 언어적 완성도 측면(이론상)에서 만든 것이기 때문에 int를 사용하는 것이 좋다.<br><br>

### • 자료형의 종류 : 실수

\- 실수를 표현할 때는 근사치로 표현이 된다. (딱 떨어지는 실수라도 하더라도 그것은 컴퓨터 입장에선 근사치로 표현한 것이다.)<br><br>

#### <b>실수형에서 선호하는 데이터 타입은?</b>

\- 두 근사치를 연산했을 경우 오차가 발생하게 되는데 이때, 해상도가 다른 두 근사치를 연산한다는 것은 오차이 범위가 너 커지게 된다. 그렇기 때문에 두 데이터타입을 섞어서 사용하는 것보다 같은데이터타입으로 통일하는 것이 가장 바람직 하다.<br>
\- 일반적으로는 double을 많이 사용한다.<br><br>

```
for(float a = 0; a < 20.0; a++) { ... }
```

위의 코드는 문제없이 잘 돌아가긴 하지만 사실상 의미가 없는 코드라고 할 수 있다.<br>
일반적으로 반복문에서 초기값, 조건, 증감은 횟수를 표현하기 위한것으로 사용되어 지는데 해당 데이터타입을 float으로 할 경우 근사치로 판단되기 때문에 20번 돌아간다는 의미보단 20번쯤 돌아간다는 의미로 해석되기 때문에 반복문에서 float은 피해야한다.<br><br>

---

<br>

## 상수와 형변환

### • 상수

\- 상수는 값이 변하지 않는 변수이다.<br>
\- 한번 초기화되면 값을 변경할 수 없는 변수를 의미한다.<br><br>

#### <b>final</b>

\- final은 변수를 바꿀 수 없는 상수화로 만드는 키워드이다.<br><br>

#### <b>상수를 왜 만드는가?</b>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc5cdSf%2FbtrS6ZAcYSt%2F9tNurxQTjttUkU0vjRAlz1%2Fimg.png" width="80%"/>

상수를 만드는 가장 첫번째 이유는 가능성을 없애는 것이다.<br>
위의 코드를 확인해보면 MAX_SIZE에 final을 사용했기 때문에 중간에 값이 바뀌면 문제가 발생될 것이다.<br>
그런데 만약 final이 아니라 int로 설정했을 경우엔 지금 당장 값이 바뀌게 되지 않더라도 언젠가는 <b>바뀔 수 있는 것</b>이다.<br>
즉, 값이 나중에 바껴도 문제될게 없는 가능성이 내포되어 있는 상태인 것이다.<br>
그래서 가능성을 아예 없애 버리는 것이며, 이로인해 프로그램이 단단해져 강건성이 높아지는 것이다.<br><br>

그리고 두번째 이유는 상수화를 함으로써 적응성(adaptive) 기능도 같이 표현할 수 있다.<br>
만약 추후에 MAX_SIZE의 값이 20으로 바뀌면 여러부분에 값을 대입하는 것이 아니라 final로 중간에 값이 변경된 적 없기 때문에 상단에 한번만 변경해주면 모든 코드가 변경된 값을 적용해 오류없이 빠르게 동작되는 것을 확인할 수 있다.<br><br>

### • 리터럴 상수 (Literals)

\- 리터럴 상수는 변수를 상수화한 것이 아닌 바꿀 수 없는 스칼라 값이라고 한다.<br>
\- 리터럴은 왼쪽에 올 수 없으며, 반드시 오른쪽에 있다. (= r value)<br>
\- 리터럴도 왼쪽의 변수에 대입되므로 메모리에 적재가 되는데 이때문에 크기와 규칙이 필요하다.<br><br>

### • 형 변환 (type casting, type conversion)

```
// 형변환1 - 새로운 데이터 타입의 변수에 대입되는 것
short a = 10;
int b = a;

// 형변환2 - 특정 데이터타입에 다른 데이터타입의 리터럴값이 대입되는 것
double a = 1.0f;
```

<br>

\- 형변환은 데이터타입의 규칙을 변화시키는 연산이다.<br><br>

#### <b>형 변환은 바람직한 것인가?</b>

형변환이 발생되는 것은 기본적으로 좋을 게 없다.<br>
그렇기 때문에 형변환을 어떻게 잘하느냐가 중요한 것이 아니라 어떻게 형변환을 안시키고 데이터타입을 설정하느냐가 더 중요하다.<br><br>

그런데 굳이 한다면 형변환 결과가 논리적으로 유효해야 한다.<br><br>

#### <b>형 변환 절차</b>

1 . 형변환은 안일으키는것이 제일 좋다.<br>
2 . 형변환이 이루어졌을 경우 논리적으로 유효한 것인지 확인한다.<br>
3 . 논리적으로 맞다고 했을 경우 반드시 디버거로 값을 확인해 추가적인 문제가 있는지 확인해 본다.<br><br>

#### <b>형 변환 원칙</b>

\- 형변환은 묵시적으로 이루어질 수 있다.<br>
\- 크기가 맞지 않은 경우 형변환이 불가능 한다.<br>
\- 명시적인 형변환은 그 결과를 장담할 수 없으나 최대한 논리적인 결과를 도출하려고는 하지만 항상 결과를 디버거로 확인해보고 정상적으로 형변환이 이루어졌는지 확인해보고, 상황에 따라 바뀔 수 있는 것까지 예측해서 확인해보보는 것이 좋다.<br><br>

---

<br>

## 연산자

### • 연산자

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F8F1Ta%2FbtrS3GI1izq%2FpG0ArhmEj4AEo50Hi2WKZ1%2Fimg.png" width="100%"/>

\- 연산자는 오퍼랜드를 연산하기 위한 명령어 이다.<br>
\- <b>OPcode 연산자 (operation code)</b><br>
\- <b>Operand 피연산자</b> : 연산자의 대상<br><br>

#### <b>특징</b>

\- 연산자에는 우선순위가 존재한다.<br>
\- 연산은 단일값의 결과를 발생시키며 이러한 결과가 평가가 가능하다면 해당 코드블럭을 <b>Expression</b>이라고 할 수 있다.<br><br>

```
int a = 10 + 5 * 2;		// Expression: 10 + 5 * 2;
```
 
<br><br>

#### <b>종류</b>

```
int a;

a = 5 + 6;		// 산술연산 - 사칙연산 
a = 4;			// 산술연산 - a=4를 수행하고 나오는 결과를 평가하기 때문에 산술연산에 해당한다.

if(k > 20)		// 논리연산 - true / false
```

\- <b>산술연산</b> : 사칙연산, 쉬프트연산 등 결과가 산술값이 나오는 연산이다.<br>
\- <b>논리연산</b> : 연산의 결과가 true나 false인 논리값이 나오는 연산이다.<br><br>

### • Short-Circuit Evaluation (Lazy Evaluation)

\- 논리연산에서 연산의 효율을 높기이 휘해 불필요한 연산을 생략하는 논리연산 최적화 메카니즘(동작방식)이다.<br><br>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcD7lVw%2FbtrS43jIHA5%2FQfckknKDuNYqvtEh0vU5h0%2Fimg.png" width="60%"/>

위의 코드를 동작했을 경우 콘솔에 찍어서 확인해보면 우리의 예상과는 다르게 "false 10 0"이 나온다.<br>
이유는 바로 논리연산 최적화 메카니즘 때문인데 앞부분에서 ((num1 += 10) < 0)은 false값을 나타낸다.<br>
그런데 뒤에 논리연산자 &&가 나왔을 경우에 앞부분에서 false값이 나오면 뒤에는 보나마나 false값이 나오기 때문에 뒤에 를 확인하지 않고 바로 false로 내보내기 때문에 ((num2 += 10) > 0)과정을 거치지 못해 num2가 0이 나오게 되는 것이다.<br><br>

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FcE4bsi%2FbtrS8uNAG3e%2FJNyXMqyCnaExu6qPVlXkMK%2Fimg.png" width="40%"/>

위의 문제를 해결하기 위해선 결국 논리연산을 사용할때 산술연산을 함께 사용하지 않고 논리연산이 들어가기 전에 미리 산술연산을 해주고 논리연산을 하는것이 바람직하다.<br> 

### • 임시변수

개발자가 명시적으로 선언하는게 아니라 컴파일러가 선언하여 만든 변수다.<br> 
컴파일러가 변수이름을 지은것이기 때문에 컴파일러는 해당 변수에 접근이 가능하지만 개발자는 접근이 불가능하다.<br> <br> 

임시변수는 코드를 간단하게 할 수 있는 장점을 가지고 있지만 과도한 사용은 코드의 복잡도를 올린다.<br> <br> 

#### <b>임시변수 사용방법 3가지</b>

임시변수는 크게 3가지로 쓰이는데 예시를 보고 잘 기억하도록 한다.<br> <br> 

#### <b>1) 대놓고 사용하기</b>

```
new NodeData();
```

NodeData를 힙에 저장하고 임시변수에 시작주소를 넣는다.<br> 
인간이 접근할 수 없다.<br> <br> 

```
int val = (new NodeData()).getIntValue();
```

명시적으로 직접접근은 못하지만 묵시적으로 선언한걸 위에처럼 접근이 가능하다.<br> 
즉, 임시변수로 접근할 수는 없지만 간접적으로 접근이 가능한 것이다.<br> <br> 

#### <b>2) 함수의 리턴값으로 임시변수 사용</b>

```
public static NodeData test()
{
	return new NodeData();	// 새로운 노드데이터를 만들고 참조값을 리턴함
}

int a = (test()).getIntValue();
System.out.println(a);
``` 

함수에서 리턴할때 임시변수를 사용해서 test를 부르면 리턴으로부터 오는 참조값을 통해 임시변수를 처리할 수 있다.<br> <br> 

#### <b>3) 함수의 파라미터로 임시변수 사용</b>

```
System.out.println((test()).getIntValue());
```

임시변수를 만들어서 test를 만질 수 있으며, 거기에 getIntValue()의 값을 임시변수에 넣고 그 변수를 또 임시변수에 넣은다음에 콘솔로 찍은 것이다.

---

<br>

## 실행 흐름 제어

### • 조건문

```
// if문
if(Boolean-expression){ ... }

// if-else문 (else는 생략하고 싶으면 생략가능)
if(Boolean-expression){ ... }
else { ... }

// if-else if문
if(Boolean-expression) { ... }
else if(Boolean-expression) { ... }
else if(Boolean-expression) { ... }
else {...}
```
조건문에는 if문, if-else문, if-else if문이 있다.<br>
이때 우리가 가장 중요하게 생각해야 할 것은 조건문안에는 Boolean-expression이 들어간다는 것인데 Boolean-expression은 논리연산을 나타내며 이말은 즉 논리연산안에 산술연산이 들어가면 안된다는 것을 의미하니 꼭 기억하도록 하자.<br><br>

### • 삼항 연산

```
Boolean-expression ? expression-1 : expression-2
```

삼항 연산은 Boolean-expression이 true일경우 expression-1으로 값을 설정하고, false일 경우 expression-2로 값을 설정한다.<br>
코드가 간단한 장점을 가지고 있지만 잘못사용하면 오히려 복잡해 질 수 있기 때문에 가급적 사용을 피하는 것이 좋다.<br><br>

### • 반복문

\- <b>for문</b> : 반복횟수가 정해진 경우<br>
\- <b>while문</b> : 반복횟수가 정해지지 않은 경우<br>
\- <b>do-while문</b> : 반복횟수가 정해지지 않은 경우, 조건검사를 실행 후 수행<br><br>

\- <b>break</b> : 가장 가까운 반복문을 탈출한다.<br>
\- <b>continue</b> : 다음 반복문을 이어나가기위해 조건검사로 점프한다.<br>

---

<br>

## 메소드와 변수의 스코프

### • 메소드

메소드는 클래스에 소속된 함수로 기능을 수행하기 위한 명령어 집합이다.<br><br>

#### <b>메소드의 기본 구조</b>

\- <b>리턴형</b> : 기능(명령)을 실행한 결과<br>
\- <b>메소드이름</b> : 메소드를 호출하기 위한 이름<br>
\- <b>파라미터</b> : 기능을 수행하기 위해 필요한 데이터들<br><br>

#### <b>메소드를 잘 만드는 법</b>

<b>1 . 함수명 </b><br>

\- 함수명은 가급적 최대 3개 단어로 만들어야 한다.<br>
\- (동사 + 목적어 + 부사)식으로 이름을 짠다.<br>
\- 함수명만 봐도 용도를 분명하게 인식할 수 있어야 한다.<br>
\- 만약 함수명을 만들기 어려울 경우, 이것은 함수의 디자인이 애초에 잘못되었을 가능성이 매우 높기 때문에 함수를 다시 확인해 보아야한다.<br><br>

>ex) 콜라 자판기에서 콜라도 나오고, 택배도 받고, 영상통화가 된다는 건 애초에 자판기가 이상한 것이다.

<br>
 

<b>2 . 리턴값 </b><br>

\- 리턴값은 상식적이어야한다.<br>
\- 함수명과 어울려야 한다.<br><br>

<b>3 . 파라미터</b><br>

\- 상식적이어야 하며, 함수명과 어울려야 한다.<br>
\- 최소한의 파라미터로 구성되어야 한다.<br>
\- <b>확장성과, 적응성이 고려</b>되어야 한다. → 추후에 변경될것에 대한 예방차원에서 유연성을 갖추어야 한다!!<br><br>

### • 스코프

\- 변수가 메소드가 호출되거나 I/O가 어느영역까지 유효한가를 보는 것이다.<br>
\- 자바는 기본적으로 스코프가 작기 때문에 기본적으로 블록레벨 스코프이다.<br>
\- 스코프가 작다는 것은 변수를 사용할 때 헷갈릴 염려가 적기때문에 좋다.<br>
\- 스코프를 가장 잘 사용한 예가 재귀호출이다. (팩토리얼과 하노이탑)

<br><br>

[티스토리 바로가기1](https://onelight-stay.tistory.com/674)<br>

[티스토리 바로가기2](https://onelight-stay.tistory.com/675?category=583276)